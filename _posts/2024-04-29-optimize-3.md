---
title: "프로젝트 최적화(3) - 메모이제이션"
author: saemii
categories:
  - Optimize
tags:
  - [Optimize, React, Next.js]
date: 2024-04-30
last_modified_at: 2024-04-30
pin: true
---

## 📌시작하며

(작성중~)
지금까지 정적 파일들에 대한 최적화에 대해 알아봤다면, 이번에는 코드 작업에서 불필요한 리렌더링을 줄이는 방법 '메모이제이션'에 대해 알아보자.🥰

## ✅React Developer Tools

먼저 만든 리액트 컴포넌트들이 어떻게 작동하는지 확인하기 위해서 **React Developer Tools**를 사용할 수 있다. Chrome, Firefox, Edge 버전이 있는데 Chrome을 주로 사용하기 때문에 [크롬버전](https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en&pli=1)으로 다운로드 하자.

이제 리렌더링 되는 상황을 발생시켜 검사 > Profile 탭에서 컴포넌트들의 렌더링을 **녹화**해서 확인하면 된다.

이때, 어떻게 리렌더링 되는지 쉽게 확인하기 위해서는 최상위 컴포넌트에서 state를 변경시켜주면 된다.

> 예를 들어 버튼을 눌러 count를 증가시키는 등의 방법으로 강제 리렌더링을 발생시킬 수 있다.

그러면 이러한 값들 중 동적인 값이 아님에도 불구하고 자주 리렌더링 되는 요소를 발견할 수 있다! 굳이 렌더링 될 필요가 없는 것을 위해 연산을 하고 있으니 성능에 좋지 않은 영향을 미칠거라는걸 쉽게 짐작할 수 있다.🤔

그러면 이러한 것들은 어떻게 처리할 수 있을까?

## ✅memo

먼저 컴포넌트를 메모해보자. memo를 사용하면 **컴포넌트의 props가 변경되지 않은 경우** 리렌더링을 건너뛸 수 있다.

```javascript
import { memo } from "react"

const SomeComponent = memo(function SomeComponent(props) {
  // ...
})
```

### ➡️memo가 필요한 상황

memo를 사용할 때는, 컴포넌트가 정확히 동일한 props로 자주 리렌더링 되고, 리렌더링 로직이 비용이 많이 드는 경우에만 유용하다. 만약 컴포넌트가 리렌더링 될 때 인지할 수 있을 만큼의 지연이 발생하지 않는다면, memo를 사용할 필요가 없다.

## ✅useCallback

```javascript
import { useCallback } from 'react';

export default function ProductPage({ productId, referrer, theme }) {
  const handleSubmit = useCallback((orderDetails) => {
    post('/product/' + productId + '/buy', {
      referrer,
      orderDetails,
    });
  }, [productId, referrer]);
```

## ✅useMemo

## ✅useCallback vs useMemo

## 📩마무리

이렇게 리액트에서 메모이제이션 하는 방식을 알아보았다. 하지만 여기서 꼭 주의해야할 점은, 메모한다고 무조건 성능을 향상시킬 수 있는 건 아니라는 것이다.

자주 변동 되는 값은 메모를 해도 아무런 효과를 발휘하지 못한다. 이런 경우 memo를 굳이 사용할 필요가 없을 뿐 더러, 오히려 불필요한 memo 연산이 사용되는 것이다.😅

**즉 꼭 필요한 상황에서 적절히 사용할 것!** 에 주의하자

## 🗂️참고 사이트

- https://ko.react.dev/learn/react-developer-tools
- https://ko.react.dev/reference/react/memo
- https://ko.react.dev/reference/react/useCallback
- https://ko.react.dev/reference/react/useMemo
