# DevTools와 친숙해지기

개발 블로그를 읽다가 "개발자는 DevTools와 꼭 친숙해져야 한다"라는 말을 보았다. 개인적으로 아직 DevTools와 아주 친숙한 사이는 아니었는데, 성능 개선과 디버깅을 좀 파헤쳐 보고 싶어서 아직 낯선 탭들에 대해 자세히 알아가보자 한다.

그 중에서 이번에는 Memory 탭에 대해 정리해보고자 한다.

# 메모리

자바스크립트는 고수준 언어로서, 개발자가 변수에 값을 할당할 때 메모리를 신경쓰지 않아도 되고, 필요없는 경우는 GC(가비지 컬렉터)가 자동으로 처리해준다.

문제는 GC가 전부 처리하지 못하는 경우가 발생할 수도 있다는 것인데, 참조를 제거하지 않아서 GC가 메모리를 회수하지 못하는 경우 필요없는 리소스가 메모리 자리를 차지하게 되는 상황, 즉 **메모리 누수**가 발생하고, 이는 성능 저하를 야기할 수 있다.

점점 복잡해지는 현대 웹에서 메모리 관리는 FE 개발자로서 마주한 중요한 이슈임에 틀림없는 것이다. 🫡

대표적으로 메모리 누수가 발생할 수 있는 상황으로는,

1. eventListener를 제거하지 않는 경우
2. timer를 정리하지 않는 경우
3. Closure에서 불필요한 참조가 계속되는 경우

가 있다.

## 모든 메모리 누수가 위험할까?

메모리 누수에는 두 가지 종료가 있다.

1. Static Memory Leak
   프로그램을 몇 번 실행하든 메모리 누수의 크기가 동일한 경우이다.
2. Dynamic/Increasing Memory Leack
   프로그램을 실행할 때마다 점점 더 많은 메모리를 할당하는 경우이다.
   대부분의 경우 이 경우의 메모리 누수가 프로그램에 악영향을 끼치고, 가장 먼저 해결해야 한다.

그럼 메모리 누수 디버깅은 어떻게 진행할까?

## 메모리 누수 디버깅 진행 전 참고 사항

메모리 누수 디버깅을 시작하기 전 다음과 같이 디버깅 환경을 만들자.

1. Chrome extension 등의 확장 프로그램이 측정값에 영향을 미치지 않도록 **시크릿 모드**를 사용한다.
2. 항상 Application의 Production Build를 디버깅 하자. 왜냐하면, 개발 모드에서 대부분의 프레임워크는 측정 값에 영향을 줄 수 있는 다양한 작업을 내부적으로 수행하기 때문이다.

자 이론은 그럭저럭 괜찮았다! 그런데...

# 메모리 누수 디버깅

문제는 프로젝트가 이미 진행된 상황에서 메모리 누수를 뒤늦게 발견했다고 해보자. 이때 어디서 메모리 누수가 발생하는지 찾으려면 어떻게 해야할까?

바로 이럴 때 Chrome DevTools의 **Performance 탭**과 **Memory 탭**이 진가를 발휘한다!⭐

## Performance 탭

Perfomrance 탭에서는 메모리가 할당되는 방식에 대한 일반적인 개요를 얻을 수 있다.

상단의 Memory Checkbox가 True인 상태에서 GC를 수동으로 트리거해 메모리에서 해제될 수 있는 모든 것이 실제로 해제되었는지 확인한 후, 애플리케이션 점검을 시작해자.

메모리 누수가 의심 되는 특정 작업을 반복해보자.

### JS heap

GC가 수행됨에도 JS heap의 그래프가 우상향으로 증가하고 있는 그래프로 나타났다면 메모리 누수가 발생했음을 짐작할 수 있다.

JS heap 그래프를 확인해보자.

> **✨알아 두기!**
> 모든 메모리 누수가 위험한 것은 아니지만, 먼제 얼마만큼의 메모리가 최초 할당되었으며, 얼마 만큼 증가되었는지를 확인해 애플리케이션에 어느정도 영향을 미치는지 짐작할 수 있다.

이제 좀 더 자세한 디버깅을 위해 메모리 탭으로 이동하자.

## Memory 탭의 주요 기능들

그럼 메모리 탭에는 어떤 [profiling type](https://developer.chrome.com/docs/devtools/memory)이 존재하며 각각의 역할은 무엇이 있는지 알아보자.

### 1. Heap snapshot (힙 스냅샷)

페이지의 JavaScript 객체들과 관련 DOM 노드들 사이의 메모리 분포를 보여준다. 특정 시점의 메모리 상태를 사진 찍듯이 캡처해서 어떤 객체들이 얼마나 메모리를 차지하고 있는지 상세히 분석할 수 있다.

### 2. Allocation instrumentation on timeline (타임라인 할당 추적)

시간에 따른 JavaScript 메모리 할당을 추적해서 보여준다. 프로파일이 녹화되면 특정 시간 구간을 선택해서 그 구간 내에서 할당되었으면서 녹화 종료 시점까지 살아있는 객체들을 확인할 수 있다. 메모리 누수를 찾을 때 특히 유용하다.

### 3. Allocation sampling (할당 샘플링)

샘플링 방식을 사용해서 메모리 할당을 기록한다. 이 프로파일 타입은 성능 오버헤드가 최소화되어 있어서 장시간 실행되는 작업에도 사용할 수 있다. JavaScript 실행 스택별로 분류된 할당 정보의 정확한 근사치를 제공한다.

### 4. Detached elements (분리된 요소들)

JavaScript 참조에 의해 유지되고 있는 객체들을 보여준다. 주로 DOM에서는 제거되었지만 JavaScript에서 여전히 참조하고 있어서 가비지 컬렉션되지 않는 요소들을 찾는 데 사용한다.

- <https://developer.chrome.com/docs/devtools/memory?hl=ko>
- <https://www.youtube.com/watch?v=6IlTjqU_Tc0&t=50s&ab_channel=DecodedFrontend>
