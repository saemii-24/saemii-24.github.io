# DevTools와 친숙해지기

개발 블로그를 읽다가 "개발자는 DevTools와 꼭 친숙해져야 한다"라는 말을 보았다. 개인적으로 아직 DevTools와 아주 친숙한 사이는 아니었는데, 성능 개선과 디버깅을 좀 파헤쳐 보고 싶어서 아직 낯선 탭들에 대해 자세히 알아가보자 한다.

그 중에서 이번에는 Memory 탭에 대해 정리해보고자 한다.

# 메모리

자바스크립트는 고수준 언어로서, 개발자가 변수에 값을 할당할 때 메모리를 신경쓰지 않아도 되고, 필요없는 경우는 GC(가비지 컬렉터)가 자동으로 처리해준다.

문제는 GC가 전부 처리하지 못하는 경우가 발생할 수도 있다는 것인데, 참조를 제거하지 않아서 GC가 메모리를 회수하지 못하는 경우 필요없는 리소스가 메모리 자리를 차지하게 되는 상황, 즉 **메모리 누수**가 발생하고, 이는 성능 저하를 야기할 수 있다.

점점 복잡해지는 현대 웹에서 메모리 관리는 FE 개발자로서 마주한 중요한 이슈임에 틀림없는 것이다. 🫡

대표적으로 메모리 누수가 발생할 수 있는 상황으로는,

1. eventListener를 제거하지 않는 경우
2. timer를 정리하지 않는 경우
3. Closure에서 불필요한 참조가 계속되는 경우

가 있다.

## 모든 메모리 누수가 위험할까?

메모리 누수에는 두 가지 종료가 있다.

1. Static Memory Leak
   프로그램을 몇 번 실행하든 메모리 누수의 크기가 동일한 경우이다.
2. Dynamic/Increasing Memory Leack
   프로그램을 실행할 때마다 점점 더 많은 메모리를 할당하는 경우이다.
   대부분의 경우 이 경우의 메모리 누수가 프로그램에 악영향을 끼치고, 가장 먼저 해결해야 한다.

그럼 메모리 누수 디버깅은 어떻게 진행할까?

## 메모리 누수 디버깅 진행 전 참고 사항

메모리 누수 디버깅을 시작하기 전 다음과 같이 디버깅 환경을 만들자.

1. Chrome extension 등의 확장 프로그램이 측정값에 영향을 미치지 않도록 **시크릿 모드**를 사용한다.
2. 항상 Application의 Production Build를 디버깅 하자. 왜냐하면, 개발 모드에서 대부분의 프레임워크는 측정 값에 영향을 줄 수 있는 다양한 작업을 내부적으로 수행하기 때문이다.

자 이론은 그럭저럭 괜찮았다! 그런데...

# 메모리 누수 디버깅

문제는 프로젝트가 이미 진행된 상황에서 메모리 누수를 뒤늦게 발견했다고 해보자. 이때 어디서 메모리 누수가 발생하는지 찾으려면 어떻게 해야할까?

바로 이럴 때 Chrome DevTools의 **Performance 탭**과 **Memory 탭**이 진가를 발휘한다!⭐

## Performance 탭

Perfomrance 탭에서는 메모리가 할당되는 방식에 대한 일반적인 개요를 얻을 수 있다.

상단의 Memory Checkbox가 True인 상태에서 GC를 수동으로 트리거해 메모리에서 해제될 수 있는 모든 것이 실제로 해제되었는지 확인한 후, 애플리케이션 점검을 시작해자.

메모리 누수가 의심 되는 특정 작업을 반복해보자.

### JS heap

GC가 수행됨에도 JS heap의 그래프가 우상향으로 증가하고 있는 그래프로 나타났다면 메모리 누수가 발생했음을 짐작할 수 있다.

JS heap 그래프를 확인해보자.

> **✨알아 두기!**
> 모든 메모리 누수가 위험한 것은 아니지만, 먼제 얼마만큼의 메모리가 최초 할당되었으며, 얼마 만큼 증가되었는지를 확인해 애플리케이션에 어느정도 영향을 미치는지 짐작할 수 있다.

이제 좀 더 자세한 디버깅을 위해 메모리 탭으로 이동하자.

## Memory 탭의 주요 기능들

그럼 메모리 탭에는 어떤 [profiling type](https://developer.chrome.com/docs/devtools/memory)이 존재하며 각각의 역할은 무엇이 있는지 알아보자.

### 1. Heap snapshot (힙 스냅샷)

페이지의 JavaScript 객체들과 관련 DOM 노드들 사이의 메모리 분포를 보여준다. 특정 시점의 메모리 상태를 사진 찍듯이 캡처해서 어떤 객체들이 얼마나 메모리를 차지하고 있는지 상세히 분석할 수 있다.

### 2. Allocation instrumentation on timeline (타임라인 할당 추적)

시간에 따른 JavaScript 메모리 할당을 추적해서 보여준다. 프로파일이 녹화되면 특정 시간 구간을 선택해서 그 구간 내에서 할당되었으면서 녹화 종료 시점까지 살아있는 객체들을 확인할 수 있다. 메모리 누수를 찾을 때 특히 유용하다.

### 3. Allocation sampling (할당 샘플링)

샘플링 방식을 사용해서 메모리 할당을 기록한다. 이 프로파일 타입은 성능 오버헤드가 최소화되어 있어서 장시간 실행되는 작업에도 사용할 수 있다. JavaScript 실행 스택별로 분류된 할당 정보의 정확한 근사치를 제공한다.

### 4. Detached elements (분리된 요소들)

JavaScript 참조에 의해 유지되고 있는 객체들을 보여준다. 주로 DOM에서는 제거되었지만 JavaScript에서 여전히 참조하고 있어서 가비지 컬렉션되지 않는 요소들을 찾는 데 사용한다.

디버깅을 위해 Allocation instrumentation에서 만든 컴포넌트들과 상호작용을 해보자.
그러면 상단에서 각 동작에 할당된 메모리 양을 나타내는 힙이 표시되는 것을 확인할 수 있다.
녹화를 중지하고 각 상황에서 어떤객체가 생성되거나 할당되었는지 확인하자.

확인하는 양을 점점 늘렸을 떄, mount, unmount를 반복했으나 꾸준히 증가하는 객체 인스턴스 수가 증가하면 메모리 누수를 의심할 수 있다.

또한 화면에서 사용되지 않고있ㅇ므에도 불구하고 할당된 객체의 경우 (예를들어 모달 등) 메모리 누수를 의심해야 한다.

이제 메모리 누수가 되고 있는 컴포넌트를 참조하고 있어 GC를 방해하고 있는지 확인해보자.
하단의 Retainers를 끌어올리자.
이 탭에는 의심가는 객체를 참조하는 최종 Retainer가 포함되어 있다.

heap snapshot을 클릭하고 페이지를 reload하자.
그 다음 녹화 버튼을 클릭한다.

이 과정을 통해 애플리케이션의 초기 메모리 스냅샷을 만들 수 있다.

그 다음 메모리 누수를 일으킬 수 있을 법한 특정 작업을 수행한다.
그리고 다시 다음 스냅샷을 녹화한다.

그 다음 먼저 녹화한 Snapshot과 비교할 수 있도록 상단의
Objects allocated between Snapshot 1 and Snapshot 2를 클릭한다.

또한 Dropdown을 클릭해 Compariosn 상태에서 비교해볼 수 있다.
이를 통해 두 번째 스냅샷과 첫 번째 스냅샷을 비교해 볼 수 있다.

1. NEW
2. Deleted
3. Delta
   델타는 생성된 객체와 삭제된 객체의 차이를 나타내며, + (양의 값)델 타는 잠재적인 메모리 누수를 나타낼 수 있다.

메모리 누수를 의심하는 지점이 이 과정을 통해 발견되었을 떄, 이 상태에서 다시 한 번 스냅샷을 찍어 동일한 양상이 나타나는지 확인하고, 최종적으로 확인되었다면 이제 코드에서 처리해주면 된다!

# Detached Element

Detached Element들은 특정 element가 DOM에서 사라 졌으나, 여전히 Javascript code에서 참조되고 있는 상태를 말한다.

위에서 이미 살펴본 것 과 같이, Detached element가 모두 위험한 것은 아니지만, 메모리 누수가 발생학고 있는 경우가 있으니 이를 어떻게 찾아낼 수 있는지 알아보자.

## Memory 탭 또 너야?

위에서 살펴 본 Memory 탭의 4가지 옵션 중 가장 마지막 Detached elements를 선택하자.
이름부터 직관적으로 Detached Element를 찾는 것으로 이해할 수 있다. 디버깅 방식은 Heep Snapshot을 찍어 확인하는 것과 유사하다.

이렇게 Detached Elements를 발견하면, 이 경우 Retainers를 찾는 기능까진 제공되지 않기 때문에 다시 Heap snapshot을 찍어 위의 내용을 반복하고 검색을 통해 해당 Detached Element를 찾아 Retainers를 확인할 수 있다.

- <https://developer.chrome.com/docs/devtools/memory?hl=ko>
- <https://www.youtube.com/watch?v=6IlTjqU_Tc0&t=50s&ab_channel=DecodedFrontend>
